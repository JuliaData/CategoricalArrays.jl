var documenterSearchIndex = {"docs":
[{"location":"using/#Using-CategoricalArrays","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"","category":"section"},{"location":"using/#Basic-usage","page":"Using CategoricalArrays","title":"Basic usage","text":"","category":"section"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"Suppose that you have data about four individuals, with three different age groups. Since this variable is clearly ordinal, we mark the array as such via the ordered argument.","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"julia> using CategoricalArrays\n\njulia> x = CategoricalArray([\"Old\", \"Young\", \"Middle\", \"Young\"], ordered=true)\n4-element CategoricalArray{String,1,UInt32}:\n \"Old\"\n \"Young\"\n \"Middle\"\n \"Young\"\n","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"By default, the levels are lexically sorted, which is clearly not correct in our case and would give incorrect results when testing for order. This is easily fixed using the levels! function to reorder levels:","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"julia> levels(x)\n3-element Vector{String}:\n \"Middle\"\n \"Old\"\n \"Young\"\n\njulia> levels!(x, [\"Young\", \"Middle\", \"Old\"])\n4-element CategoricalArray{String,1,UInt32}:\n \"Old\"\n \"Young\"\n \"Middle\"\n \"Young\"\n","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"Thanks to this order, we can not only test for equality between two values, but also compare the ages of e.g. individuals 1 and 2:","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"julia> x[1]\nCategoricalValue{String, UInt32} \"Old\" (3/3)\n\njulia> x[2]\nCategoricalValue{String, UInt32} \"Young\" (1/3)\n\njulia> x[2] == x[4]\ntrue\n\njulia> x[1] > x[2]\ntrue\n","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"Now let us imagine the first individual is actually in the \"Young\" group. Let's fix this (notice how the string \"Young\" is automatically converted to a CategoricalValue):","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"julia> x[1] = \"Young\"\n\"Young\"\n\njulia> x[1]\nCategoricalValue{String, UInt32} \"Young\" (1/3)\n","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"The CategoricalArray still considers \"Old\" as a possible level even if it is unused now. This is necessary to allow efficiently accessing the levels and setting values of elements in the array: indeed, dropping unused levels requires iterating over every element in the array, which is expensive. This property can also be useful to keep track of possible levels, even if they do not occur in practice.","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"To get rid of the \"Old\" group, just call the droplevels! function:","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"julia> levels(x)\n3-element Vector{String}:\n \"Young\"\n \"Middle\"\n \"Old\"\n\njulia> droplevels!(x)\n4-element CategoricalArray{String,1,UInt32}:\n \"Young\"\n \"Young\"\n \"Middle\"\n \"Young\"\n\njulia> levels(x)\n2-element Vector{String}:\n \"Young\"\n \"Middle\"\n","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"Another solution would have been to call levels!(x, [\"Young\", \"Middle\"]) manually. This command is safe too, since it will raise an error when trying to remove levels that are currently used:","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"julia> levels!(x, [\"Young\", \"Midle\"])\nERROR: ArgumentError: cannot remove level \"Middle\" as it is used at position 3. Change the array element type to Union{String, Missing} using convert if you want to transform some levels to missing values.\n[...]\n","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"Note that entries in the x array cannot be treated as strings. Instead, they need to be converted to strings using String(x[i]):","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"julia> lowercase(String(x[3]))\n\"middle\"\n\njulia> replace(String(x[3]), 'M'=>'R')\n\"Riddle\"","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"Note that the call to String does not reduce performance compared with working with a Vector{String} as it simply returns the string object which is stored by the pool.","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"Integer codes giving the index of each value in the levels can be obtained using the levelcode function:","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"julia> levelcode(x[1])\n1\n\njulia> levelcode.(x)\n4-element Vector{Int64}:\n 1\n 1\n 2\n 1","category":"page"},{"location":"using/#Handling-Missing-Values","page":"Using CategoricalArrays","title":"Handling Missing Values","text":"","category":"section"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"The examples above assumed that the data contained no missing values. This is generally not the case for real data. This is where CategoricalArray{Union{T, Missing}} comes into play. It is essentially the categorical-data equivalent of Array{Union{T, Missing}}. It behaves exactly as CategoricalArray{T}, except that when indexed it returns either a CategoricalValue{T} object or missing if the value is missing. See the Julia manual for more information on the Missing type.","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"Let's adapt the example developed above to support missing values. Since there are no missing values in the input vector, we need to specify that the array should be able to hold either a String or missing:","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"julia> y = CategoricalArray{Union{Missing, String}}([\"Old\", \"Young\", \"Middle\", \"Young\"], ordered=true)\n4-element CategoricalArray{Union{Missing, String},1,UInt32}:\n \"Old\"\n \"Young\"\n \"Middle\"\n \"Young\"\n","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"Levels still need to be reordered manually:","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"julia> levels(y)\n3-element Vector{String}:\n \"Middle\"\n \"Old\"\n \"Young\"\n\njulia> levels!(y, [\"Young\", \"Middle\", \"Old\"])\n4-element CategoricalArray{Union{Missing, String},1,UInt32}:\n \"Old\"\n \"Young\"\n \"Middle\"\n \"Young\"\n","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"At this point, indexing into the array gives exactly the same result","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"julia> y[1]\nCategoricalValue{String, UInt32} \"Old\" (3/3)","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"Missing values can be introduced either manually, or by restricting the set of possible levels. Let us imagine this time that we actually do not know the age of the first individual. We can set it to a missing value this way:","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"julia> y[1] = missing\nmissing\n\njulia> y\n4-element CategoricalArray{Union{Missing, String},1,UInt32}:\n missing\n \"Young\"\n \"Middle\"\n \"Young\"\n\njulia> y[1]\nmissing\n","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"It is also possible to transform all values belonging to some levels into missing values, which gives the same result as above in the present case since we have only one individual in the \"Old\" group. Let's first restore the original value for the first element, and then set it to missing again using the allowmissing argument to levels!:","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"julia> y[1] = \"Old\"\n\"Old\"\n\njulia> y\n4-element CategoricalArray{Union{Missing, String},1,UInt32}:\n \"Old\"\n \"Young\"\n \"Middle\"\n \"Young\"\n\njulia> levels!(y, [\"Young\", \"Middle\"]; allowmissing=true)\n4-element CategoricalArray{Union{Missing, String},1,UInt32}:\n missing\n \"Young\"\n \"Middle\"\n \"Young\"\n","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"Conversely, all missing values can be turned into a \"normal\" value using replace (or recode, whose syntax is identical for this operation):","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"julia> replace(y, missing => \"missing value\")\n4-element CategoricalArray{String,1,UInt32}:\n \"missing value\"\n \"Young\"\n \"Middle\"\n \"Young\"","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"Note that the returned array no longer allows for missing values (which is usually what is expected). This syntax works for array types other than CategoricalArray.","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"An in-place variant replace! (respectively recode!) is also provided. Note that y still allows for missing values (since the type of an object cannot be changed).","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"julia> replace!(y, missing => \"missing value\");\n\njulia> y\n4-element CategoricalArray{Union{Missing, String},1,UInt32}:\n \"missing value\"\n \"Young\"\n \"Middle\"\n \"Young\"","category":"page"},{"location":"using/#Combining-levels","page":"Using CategoricalArrays","title":"Combining levels","text":"","category":"section"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"Some operations imply combining levels of two categorical arrays: this is the case when concatenating arrays (vcat, hcat and cat) and when assigning a CategoricalValue from another categorical array.","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"For example, imagine we have two sets of observations, one with only the younger part of the population and one with the older part:","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"julia> x = categorical([\"Middle\", \"Old\", \"Middle\"], ordered=true);\n\njulia> y = categorical([\"Young\", \"Middle\", \"Middle\"], ordered=true);\n\njulia> levels!(y, [\"Young\", \"Middle\"]);","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"If we concatenate the two sets, the levels of the resulting categorical vector are chosen so that the relative orders of levels in x and y are preserved, if possible. In that case, comparisons with < and > are still valid, and resulting vector is marked as ordered:","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"julia> xy = vcat(x, y)\n6-element CategoricalArray{String,1,UInt32}:\n \"Middle\"\n \"Old\"\n \"Middle\"\n \"Young\"\n \"Middle\"\n \"Middle\"\n\njulia> levels(xy)\n3-element Vector{String}:\n \"Young\"\n \"Middle\"\n \"Old\"\n\njulia> isordered(xy)\ntrue","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"Likewise, assigning a CategoricalValue from y to an entry in x expands the levels of x with all levels from y, respecting the ordering of levels of both vectors if possible:","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"julia> levels(x)\n2-element Vector{String}:\n \"Middle\"\n \"Old\"\n\njulia> x[1] = y[1]\nCategoricalValue{String, UInt32} \"Young\" (1/2)\n\njulia> levels(x)\n3-element Vector{String}:\n \"Young\"\n \"Middle\"\n \"Old\"\n\njulia> x[1]\nCategoricalValue{String, UInt32} \"Young\" (1/3)","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"In cases where levels with incompatible orderings are combined, the ordering of the destination array wins and the destination array is marked as unordered. The same happens when concatenating arrays, and the ordering of the first array wins in case of conflict:","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"julia> a = categorical([\"a\", \"b\", \"c\"], ordered=true);\n\njulia> b = categorical([\"a\", \"b\", \"c\"], ordered=true);\n\njulia> ab = vcat(a, b)\n6-element CategoricalArray{String,1,UInt32}:\n \"a\"\n \"b\"\n \"c\"\n \"a\"\n \"b\"\n \"c\"\n\njulia> levels(ab)\n3-element Vector{String}:\n \"a\"\n \"b\"\n \"c\"\n\njulia> isordered(ab)\ntrue\n\njulia> levels!(b, [\"c\", \"b\", \"a\"])\n3-element CategoricalArray{String,1,UInt32}:\n \"a\"\n \"b\"\n \"c\"\n\njulia> ab2 = vcat(a, b)\n6-element CategoricalArray{String,1,UInt32}:\n \"a\"\n \"b\"\n \"c\"\n \"a\"\n \"b\"\n \"c\"\n\njulia> levels(ab2)\n3-element Vector{String}:\n \"a\"\n \"b\"\n \"c\"\n\njulia> isordered(ab2)\nfalse","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"The resulting array is marked as ordered only if all the source array(s) are ordered, with the exception that unordered arrays with no levels do not prompt the result to be marked as unordered. In particular, this allows assignment of a CategoricalValue to an empty CategoricalArray via setindex! to copy the levels of the source value and to mark the result as ordered.","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"Do note that in some cases the two sets of levels may have compatible orderings, but it is not possible to determine in what order should levels appear in the merged set. This is the case for example with [\"a, \"b\", \"d\"] and [\"c\", \"d\", \"e\"]: there is no way to detect that \"c\" should be inserted exactly after \"b\" (lexicographic ordering is not relevant here). In such cases, the resulting array is marked as unordered. This situation can only happen when working with data subsets selected based on non-contiguous subsets of levels.","category":"page"},{"location":"using/#Exported-functions","page":"Using CategoricalArrays","title":"Exported functions","text":"","category":"section"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"categorical(A) - Construct a categorical array with values from A","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"compress(A) - Return a copy of categorical array A using the smallest possible reference type","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"cut(x) - Cut a numeric array into intervals and return an ordered CategoricalArray","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"decompress(A) - Return a copy of categorical array A using the default reference type","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"isordered(A) - Test whether entries in A can be compared using <, > and similar operators","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"ordered!(A, ordered) - Set whether entries in A can be compared using <, > and similar operators","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"recode(a[, default], pairs...) - Return a copy of a after replacing one or more values","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"recode!(a[, default], pairs...) - Replace one or more values in a in-place","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"unwrap(x) - Return the value contained in categorical value x; if x is Missing               return missing","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"levelcode(x) - Return the code of categorical value x, i.e. its index                   in the set of possible values returned by levels(x).","category":"page"},{"location":"using/","page":"Using CategoricalArrays","title":"Using CategoricalArrays","text":"See API Index for more details.","category":"page"},{"location":"apiindex/#API-Index","page":"API index","title":"API Index","text":"","category":"section"},{"location":"apiindex/","page":"API index","title":"API index","text":"Modules = [CategoricalArrays]\nOrder   = [:type, :function]\nPrivate = false","category":"page"},{"location":"apiindex/#CategoricalArrays.CategoricalArray","page":"API index","title":"CategoricalArrays.CategoricalArray","text":"CategoricalArray{T}(undef, dims::Dims; levels=nothing, ordered=false)\nCategoricalArray{T}(undef, dims::Int...; levels=nothing, ordered=false)\n\nConstruct an uninitialized CategoricalArray with levels of type T <: Union{AbstractChar, AbstractString, Number} and dimensions dims.\n\nThe levels keyword argument can be a vector specifying possible values for the data (this is equivalent to but more efficient than calling levels! on the resulting array). The ordered keyword argument determines whether the array values can be compared according to the ordering of levels or not (see isordered).\n\nCategoricalArray{T, N, R}(undef, dims::Dims; levels=nothing, ordered=false)\nCategoricalArray{T, N, R}(undef, dims::Int...; levels=nothing, ordered=false)\n\nSimilar to definition above, but uses reference type R instead of the default type (UInt32).\n\nCategoricalArray(A::AbstractArray; levels=nothing, ordered=false)\n\nConstruct a new CategoricalArray with the values from A and the same element type.\n\nThe levels keyword argument can be a vector specifying possible values for the data (this is equivalent to but more efficient than calling levels! on the resulting array). If levels is omitted and the element type supports it, levels are sorted in ascending order; else, they are kept in their order of appearance in A. The ordered keyword argument determines whether the array values can be compared according to the ordering of levels or not (see isordered).\n\nIf A is already a CategoricalArray, its levels, orderedness and reference type are preserved unless explicitly overriden.\n\n\n\n\n\n","category":"type"},{"location":"apiindex/#CategoricalArrays.CategoricalMatrix","page":"API index","title":"CategoricalArrays.CategoricalMatrix","text":"CategoricalMatrix{T}(undef, m::Int, n::Int; levels=nothing, ordered=false)\n\nConstruct an uninitialized CategoricalMatrix with levels of type T <: Union{AbstractChar, AbstractString, Number} and dimensions dim. The ordered keyword argument determines whether the array values can be compared according to the ordering of levels or not (see isordered).\n\nCategoricalMatrix{T, R}(undef, m::Int, n::Int; levels=nothing, ordered=false)\n\nSimilar to definition above, but uses reference type R instead of the default type (UInt32).\n\nCategoricalMatrix(A::AbstractMatrix; levels=nothing, ordered=false)\n\nConstruct a CategoricalMatrix with the values from A and the same element type.\n\nThe levels keyword argument can be a vector specifying possible values for the data (this is equivalent to but more efficient than calling levels! on the resulting array). If levels is omitted and the element type supports it, levels are sorted in ascending order; else, they are kept in their order of appearance in A. The ordered keyword argument determines whether the array values can be compared according to the ordering of levels or not (see isordered).\n\nIf A is already a CategoricalMatrix, its levels, orderedness and reference type are preserved unless explicitly overriden.\n\n\n\n\n\n","category":"type"},{"location":"apiindex/#CategoricalArrays.CategoricalValue","page":"API index","title":"CategoricalArrays.CategoricalValue","text":"CategoricalValue{T <: Union{AbstractChar, AbstractString, Number}, R <: Integer}\n\nA wrapper around a value of type T corresponding to a level in a CategoricalPool.\n\nCategoricalValue objects are considered as equal to the value of type T they wrap by == and isequal. However, order comparisons like < and isless are only possible if isordered is true for the value's pool, and in that case the order of the pool's levels is used rather than the standard ordering of values of type T.\n\n\n\n\n\n","category":"type"},{"location":"apiindex/#CategoricalArrays.CategoricalValue-Tuple{Any, Union{CategoricalValue, Union{SubArray{<:Any, N, <:CategoricalArray{T, <:Any, R}}, CategoricalArray{T, N, R}} where {T, N, R<:Integer}}}","page":"API index","title":"CategoricalArrays.CategoricalValue","text":"CategoricalValue(value, source::Union{CategoricalValue, CategoricalArray})\n\nReturn a CategoricalValue object wrapping value and attached to the CategoricalPool of source.\n\n\n\n\n\n","category":"method"},{"location":"apiindex/#CategoricalArrays.CategoricalVector","page":"API index","title":"CategoricalArrays.CategoricalVector","text":"CategoricalVector{T}(undef, m::Int; levels=nothing, ordered=false)\n\nConstruct an uninitialized CategoricalVector with levels of type T <: Union{AbstractChar, AbstractString, Number} and dimensions dim.\n\nThe levels keyword argument can be a vector specifying possible values for the data (this is equivalent to but more efficient than calling levels! on the resulting array). The ordered keyword argument determines whether the array values can be compared according to the ordering of levels or not (see isordered).\n\nCategoricalVector{T, R}(undef, m::Int; levels=nothing, ordered=false)\n\nSimilar to definition above, but uses reference type R instead of the default type (UInt32).\n\nCategoricalVector(A::AbstractVector; levels=nothing, ordered=false)\n\nConstruct a CategoricalVector with the values from A and the same element type.\n\nThe levels keyword argument can be a vector specifying possible values for the data (this is equivalent to but more efficient than calling levels! on the resulting array). If levels is omitted and the element type supports it, levels are sorted in ascending order; else, they are kept in their order of appearance in A. The ordered keyword argument determines whether the array values can be compared according to the ordering of levels or not (see isordered).\n\nIf A is already a CategoricalVector, its levels, orderedness and reference type are preserved unless explicitly overriden.\n\n\n\n\n\n","category":"type"},{"location":"apiindex/#CategoricalArrays.categorical-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"API index","title":"CategoricalArrays.categorical","text":"categorical(A::AbstractArray; levels=nothing, ordered=false, compress=false)\n\nConstruct a categorical array with the values from A.\n\nThe levels keyword argument can be a vector specifying possible values for the data (this is equivalent to but more efficient than calling levels! on the resulting array). If levels is omitted and the element type supports it, levels are sorted in ascending order; else, they are kept in their order of appearance in A. The ordered keyword argument determines whether the array values can be compared according to the ordering of levels or not (see isordered).\n\nIf compress is true, the smallest reference type able to hold the number of unique values in A will be used. While this will reduce memory use, passing this parameter will also introduce a type instability which can affect performance inside the function where the call is made. Therefore, use this option with caution (the one-argument version does not suffer from this problem).\n\ncategorical(A::CategoricalArray; compress=false, levels=nothing, ordered=false)\n\nIf A is already a CategoricalArray, its levels, orderedness and reference type are preserved unless explicitly overriden.\n\n\n\n\n\n","category":"method"},{"location":"apiindex/#CategoricalArrays.compress-Union{Tuple{CategoricalArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"API index","title":"CategoricalArrays.compress","text":"compress(A::CategoricalArray)\n\nReturn a copy of categorical array A using the smallest reference type able to hold the number of levels of A.\n\nWhile this will reduce memory use, this function is type-unstable, which can affect performance inside the function where the call is made. Therefore, use it with caution.\n\n\n\n\n\n","category":"method"},{"location":"apiindex/#CategoricalArrays.cut-Tuple{AbstractArray, AbstractVector}","page":"API index","title":"CategoricalArrays.cut","text":"cut(x::AbstractArray, breaks::AbstractVector;\n    labels::Union{AbstractVector{<:AbstractString},Function},\n    extend::Union{Bool,Missing}=false, allowempty::Bool=false)\n\nCut a numeric array into intervals at values breaks and return an ordered CategoricalArray indicating the interval into which each entry falls. Intervals are of the form [lower, upper), i.e. the lower bound is included and the upper bound is excluded, except if extend=true the last interval, which is then closed on both ends, i.e. [lower, upper].\n\nIf x accepts missing values (i.e. eltype(x) >: Missing) the returned array will also accept them.\n\nKeyword arguments\n\nextend::Union{Bool, Missing}=false: when false, an error is raised if some values in x fall outside of the breaks; when true, breaks are automatically added to include all values in x, and the upper bound is included in the last interval; when missing, values outside of the breaks generate missing entries.\nlabels::Union{AbstractVector,Function}: a vector of strings giving the names to use for the intervals; or a function f(from, to, i; leftclosed, rightclosed) that generates the labels from the left and right interval boundaries and the group index. Defaults to \"[from, to)\" (or \"[from, to]\" for the rightmost interval if extend == true).\nallowempty::Bool=false: when false, an error is raised if some breaks appear multiple times, generating empty intervals; when true, duplicate breaks are allowed and the intervals they generate are kept as unused levels (but duplicate labels are not allowed).\n\nExamples\n\njulia> using CategoricalArrays\n\njulia> cut(-1:0.5:1, [0, 1], extend=true)\n5-element CategoricalArray{String,1,UInt32}:\n \"[-1.0, 0.0)\"\n \"[-1.0, 0.0)\"\n \"[0.0, 1.0]\"\n \"[0.0, 1.0]\"\n \"[0.0, 1.0]\" \n\njulia> cut(-1:0.5:1, 2)\n5-element CategoricalArray{String,1,UInt32}:\n \"Q1: [-1.0, 0.0)\"\n \"Q1: [-1.0, 0.0)\"\n \"Q2: [0.0, 1.0]\"\n \"Q2: [0.0, 1.0]\"\n \"Q2: [0.0, 1.0]\" \n\njulia> cut(-1:0.5:1, 2, labels=[\"A\", \"B\"])\n5-element CategoricalArray{String,1,UInt32}:\n \"A\"\n \"A\"\n \"B\"\n \"B\"\n \"B\"\n\njulia> fmt(from, to, i; leftclosed, rightclosed) = \"grp $i ($from//$to)\"\nfmt (generic function with 1 method)\n\njulia> cut(-1:0.5:1, 3, labels=fmt)\n5-element CategoricalArray{String,1,UInt32}:\n \"grp 1 (-1.0//-0.3333333333333335)\"\n \"grp 1 (-1.0//-0.3333333333333335)\"\n \"grp 2 (-0.3333333333333335//0.33333333333333326)\"\n \"grp 3 (0.33333333333333326//1.0)\"\n \"grp 3 (0.33333333333333326//1.0)\"      \n\n\n\n\n\n","category":"method"},{"location":"apiindex/#CategoricalArrays.cut-Tuple{AbstractArray, Integer}","page":"API index","title":"CategoricalArrays.cut","text":"cut(x::AbstractArray, ngroups::Integer;\n    labels::Union{AbstractVector{<:AbstractString},Function},\n    allowempty::Bool=false)\n\nCut a numeric array into ngroups quantiles, determined using quantile.\n\nIf x contains missing values, they are automatically skipped when computing quantiles.\n\nKeyword arguments\n\nlabels::Union{AbstractVector,Function}: a vector of strings giving the names to use for the intervals; or a function f(from, to, i; leftclosed, rightclosed) that generates the labels from the left and right interval boundaries and the group index. Defaults to \"Qi: [from, to)\" (or \"Qi: [from, to]\" for the rightmost interval).\nallowempty::Bool=false: when false, an error is raised if some quantiles breakpoints are equal, generating empty intervals; when true, duplicate breaks are allowed and the intervals they generate are kept as unused levels (but duplicate labels are not allowed).\n\n\n\n\n\n","category":"method"},{"location":"apiindex/#CategoricalArrays.decompress-Union{Tuple{CategoricalArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"API index","title":"CategoricalArrays.decompress","text":"decompress(A::CategoricalArray)\n\nReturn a copy of categorical array A using the default reference type (UInt32). If A is using a small reference type (such as UInt8 or UInt16) the decompressed array will have room for more levels.\n\nTo avoid the need to call decompress, ensure compress is not called when creating the categorical array.\n\n\n\n\n\n","category":"method"},{"location":"apiindex/#CategoricalArrays.droplevels!-Tuple{CategoricalArray}","page":"API index","title":"CategoricalArrays.droplevels!","text":"droplevels!(A::CategoricalArray)\n\nDrop levels which do not appear in categorical array A (so that they will no longer be returned by levels).\n\n\n\n\n\n","category":"method"},{"location":"apiindex/#CategoricalArrays.isordered-Tuple{CategoricalArray}","page":"API index","title":"CategoricalArrays.isordered","text":"isordered(A::CategoricalArray)\n\nTest whether entries in A can be compared using <, > and similar operators, using the ordering of levels.\n\n\n\n\n\n","category":"method"},{"location":"apiindex/#CategoricalArrays.levelcode-Tuple{CategoricalValue}","page":"API index","title":"CategoricalArrays.levelcode","text":"levelcode(x::CategoricalValue)\n\nGet the code of categorical value x, i.e. its index in the set of possible values returned by levels(x).\n\n\n\n\n\n","category":"method"},{"location":"apiindex/#CategoricalArrays.levelcode-Tuple{Missing}","page":"API index","title":"CategoricalArrays.levelcode","text":"levelcode(x::Missing)\n\nReturn missing.\n\n\n\n\n\n","category":"method"},{"location":"apiindex/#CategoricalArrays.levels!-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{CategoricalArray{T, N, R}, AbstractVector}} where {T, N, R}","page":"API index","title":"CategoricalArrays.levels!","text":"levels!(A::CategoricalArray, newlevels::Vector; allowmissing::Bool=false)\n\nSet the levels categorical array A. The order of appearance of levels will be respected by levels, which may affect display of results in some operations; if A is ordered (see isordered), it will also be used for order comparisons using <, > and similar operators. Reordering levels will never affect the values of entries in the array.\n\nIf A accepts missing values (i.e. eltype(A) >: Missing) and allowmissing=true, entries corresponding to omitted levels will be set to missing. Else, newlevels must include all levels which appear in the data.\n\n\n\n\n\n","category":"method"},{"location":"apiindex/#CategoricalArrays.ordered!-Tuple{CategoricalArray, Any}","page":"API index","title":"CategoricalArrays.ordered!","text":"ordered!(A::CategoricalArray, ordered::Bool)\n\nSet whether entries in A can be compared using <, > and similar operators, using the ordering of levels. Return the modified A.\n\n\n\n\n\n","category":"method"},{"location":"apiindex/#CategoricalArrays.recode","page":"API index","title":"CategoricalArrays.recode","text":"recode(a::AbstractArray[, default::Any], pairs::Pair...)\n\nReturn a copy of a, replacing elements matching a key of pairs with the corresponding value. The type of the array is chosen so that it can hold all recoded elements (but not necessarily original elements from a).\n\nFor each Pair in pairs, if the element is equal to (according to isequal) or in the key (first item of the pair), then the corresponding value (second item) is used. If the element matches no key and default is not provided or nothing, it is copied as-is; if default is specified, it is used in place of the original element. If an element matches more than one key, the first match is used.\n\nrecode(a::CategoricalArray[, default::Any], pairs::Pair...)\n\nIf a is a CategoricalArray then the ordering of resulting levels is determined by the order of passed pairs and default will be the last level if provided.\n\nExamples\n\njulia> using CategoricalArrays\n\njulia> recode(1:10, 1=>100, 2:4=>0, [5; 9:10]=>-1)\n10-element Vector{Int64}:\n 100\n   0\n   0\n   0\n  -1\n   6\n   7\n   8\n  -1\n  -1\n\n\n recode(a::AbstractArray{>:Missing}[, default::Any], pairs::Pair...)\n\nIf a contains missing values, they are never replaced with default: use missing in a pair to recode them. If that's not the case, the returned array will accept missing values.\n\nExamples\n\njulia> using CategoricalArrays\n\njulia> recode(1:10, 1=>100, 2:4=>0, [5; 9:10]=>-1, 6=>missing)\n10-element Vector{Union{Missing, Int64}}:\n 100\n   0\n   0\n   0\n  -1\n    missing\n   7\n   8\n  -1\n  -1    \n\n\n\n\n\n\n","category":"function"},{"location":"apiindex/#CategoricalArrays.recode!","page":"API index","title":"CategoricalArrays.recode!","text":"recode!(dest::AbstractArray, src::AbstractArray[, default::Any], pairs::Pair...)\n\nFill dest with elements from src, replacing those matching a key of pairs with the corresponding value.\n\nFor each Pair in pairs, if the element is equal to (according to isequal)) the key (first item of the pair) or to one of its entries if it is a collection, then the corresponding value (second item) is copied to dest. If the element matches no key and default is not provided or nothing, it is copied as-is; if default is specified, it is used in place of the original element. dest and src must be of the same length, but not necessarily of the same type. Elements of src as well as values from pairs will be converted when possible on assignment. If an element matches more than one key, the first match is used.\n\nrecode!(dest::CategoricalArray, src::AbstractArray[, default::Any], pairs::Pair...)\n\nIf dest is a CategoricalArray then the ordering of resulting levels is determined by the order of passed pairs and default will be the last level if provided.\n\nrecode!(dest::AbstractArray, src::AbstractArray{>:Missing}[, default::Any], pairs::Pair...)\n\nIf src contains missing values, they are never replaced with default: use missing in a pair to recode them.\n\n\n\n\n\n","category":"function"},{"location":"apiindex/#CategoricalArrays.recode!-Tuple{AbstractArray, Any, Vararg{Pair}}","page":"API index","title":"CategoricalArrays.recode!","text":"recode!(a::AbstractArray[, default::Any], pairs::Pair...)\n\nConvenience function for in-place recoding, equivalent to recode!(a, a, ...).\n\nExamples\n\njulia> using CategoricalArrays\n\njulia> x = collect(1:10);\n\njulia> recode!(x, 1=>100, 2:4=>0, [5; 9:10]=>-1);\n\njulia> x\n10-element Vector{Int64}:\n 100\n   0\n   0\n   0\n  -1\n   6\n   7\n   8\n  -1\n  -1\n\n\n\n\n\n","category":"method"},{"location":"apiindex/#DataAPI.levels-Tuple{CategoricalArray}","page":"API index","title":"DataAPI.levels","text":"levels(x::CategoricalArray)\nlevels(x::CategoricalValue)\n\nReturn the levels of categorical array or value x. This may include levels which do not actually appear in the data (see droplevels!).\n\n\n\n\n\n","category":"method"},{"location":"apiindex/#DataAPI.unwrap-Tuple{CategoricalValue}","page":"API index","title":"DataAPI.unwrap","text":"unwrap(x::CategoricalValue)\nunwrap(x::Missing)\n\nGet the value wrapped by categorical value x. If x is Missing return missing.\n\n\n\n\n\n","category":"method"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The package provides the CategoricalArray type designed to hold categorical data (either unordered/nominal or ordered/ordinal) efficiently and conveniently. CategoricalArray{T} holds values of type T. The CategoricalArray{Union{T, Missing}} variant can also contain missing values (represented as missing, of the Missing type). When indexed, CategoricalArray{T} returns special CategoricalValue{T} objects rather than the original values of type T. CategoricalValue is a simple wrapper around the categorical levels; it allows very efficient retrieval and comparison of actual values. See the PooledArrays.jl and IndirectArrays.jl packages for simpler array types storing data with a small number of values without wrapping them.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The main feature of CategoricalArray is that it maintains a pool of the levels which can appear in the data. These levels are stored in a specific order: for unordered arrays, this order is only used for pretty printing (e.g. in cross tables or plots); for ordered arrays, it also allows comparing values using the < and > operators: the comparison is then based on the ordering of levels stored in the array. An ordered CategoricalValue can be also compared with a value that when converted is equal to one of the levels of this CategoricalValue. Whether an array is ordered can be defined either on construction via the ordered argument, or at any time via the ordered! function. The levels function returns all the levels of CategoricalArray, and the levels! function can be used to set the levels and their order. Levels are also automatically extended when setting an array element to a level not encountered before. But they are never removed without manual intervention: use the droplevels! function for this.","category":"page"},{"location":"implementation/#Implementation-details","page":"Implementation details","title":"Implementation details","text":"","category":"section"},{"location":"implementation/","page":"Implementation details","title":"Implementation details","text":"CategoricalArray is made of the two fields:","category":"page"},{"location":"implementation/","page":"Implementation details","title":"Implementation details","text":"refs: an integer array that stores the position of the category level in the levels field of CategoricalPool for each CategoricalArray element; 0 denotes a missing value (for CategoricalArray{Union{T, Missing}} only).\npool: the CategoricalPool object that maintains the levels of the array.","category":"page"},{"location":"implementation/","page":"Implementation details","title":"Implementation details","text":"The CategoricalPool{V,R,C} type keeps track of the levels of type V and associates them with an integer reference code of type R (for internal use). It offers methods to add new levels, and efficiently get the integer index corresponding to a level and vice-versa. Whether the values of CategoricalArray are ordered or not is defined by an ordered field of the pool.","category":"page"},{"location":"implementation/","page":"Implementation details","title":"Implementation details","text":"Do note that CategoricalPool levels are semi-mutable: it is only allowed to add new levels, but never to remove or reorder existing ones. This ensures existing CategoricalValue objects remain valid and always point to the same level as when they were created. Therefore, CategoricalArrays create a new pool each time some of their levels are removed or reordered. This happens when calling levels!, but also when assigning a CategoricalValue via setindex!, push!, append!, copy! or copyto! (as new levels may be added to the front to preserve relative order of both source and destination levels). Doing so requires updating all reference codes to point to the new pool, and makes it impossible to compare existing ordered CategoricalValue objects with values from the array using < and >.","category":"page"},{"location":"implementation/","page":"Implementation details","title":"Implementation details","text":"The type parameters of CategoricalArray{T, N, R <: Integer, V, C, U} are a bit complex:","category":"page"},{"location":"implementation/","page":"Implementation details","title":"Implementation details","text":"T is the type of array elements without CategoricalValue wrappers; if T >: Missing, then the array supports missing values.\nN is the number of array dimensions.\nR is the reference type, the element type of the refs field; it allows optimizing memory usage depending on the number of levels (i.e. CategoricalArray with less than 256 levels can use R = UInt8).\nV is the type of the levels, it is equal to T for arrays which do not support missing values; for arrays which support missing values, T = Union{V, Missing}\nC is the type of categorical values, i.e. of the objects returned when indexing non-missing elements of CategoricalArray. It is always equal to CategoricalValue{V, R}, and only present for technical reasons (to break the recursive dependency between CategoricalArray and CategoricalValue).\nU can be either Union{} for arrays which do not support missing values, or Missing for those which support them.","category":"page"},{"location":"implementation/","page":"Implementation details","title":"Implementation details","text":"Only T, N and R could be specified upon construction. The last three parameters are chosen automatically, but are needed for the definition of the type. In particular, U allows expressing that CategoricalArray{T, N} inherits from AbstractArray{Union{C, U}, N} (which is equivalent to AbstractArray{C, N} for arrays which do not support missing values, and to AbstractArray{Union{C, Missing}, N} for those which support them).","category":"page"},{"location":"implementation/","page":"Implementation details","title":"Implementation details","text":"The CategoricalPool type is designed to limit the need to go over all elements of the vector, either for reading or for writing. This is why unused levels are not dropped automatically (this would force checking all elements on every modification or keeping a counts table), but only when droplevels! is called. levels is a (very fast) O(1) operation since it merely returns the (ordered) vector of levels without accessing the data at all.","category":"page"},{"location":"implementation/","page":"Implementation details","title":"Implementation details","text":"Scalar operations between CategoricalValue objects or between a CategoricalValue and a CategoricalArray generally require checking whether pools are equal or whether one is a superset of the other. In order to make these operations efficient, CategoricalPool stores a pointer to the last encountered equal pool in the equalto field, and a pointer to the last encountered strict superset pool in subsetof field. The hash of the levels is computed the first time it is needed and stored in the hash field. These optimizations mean that when looping over values in an array, the cost of comparing pools only has to be paid once.","category":"page"}]
}
